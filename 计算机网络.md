# 计算机网络协议——TCP/IP详解卷1
## 第1章 概述
1.数据报是一个特定类型的分组，**有关来源和最终目的地的所有识别信息都位于分组中(而不是分组交换机中)**。虽然这通常需要较大的数据包，但不需要在交换机中维护连接状态，它可用于建立一个无连接的网络，并且没必要使用复杂的信令协议。

2.消息边界或记录标记
![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665036911096.png)

3.在尽力而为的交付中，网络**不会花费很大努力**来确保数据在没有差错或缺陷的情况下交付。如果尽力而为的交付成功，发送方能以超过接收方处理能力的速度生成信息。在尽力而为的IP网络中，降低发送方的发送速度可通过**流量控制机制**实现。

## 第12章 TCP:传输控制协议（初步）

## 第13章 TCP连接管理
1.TCP链接的建立与中止
一个TCP链接由一个**四元组唯一标识**，分别是两个IP地址和两个端日号。

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665197347549.png)
1.1 TCP半关闭
在TCP半关闭操作中,连接的一个方向被关闭，而另一个方向仍在传输数据直到它被关闭为
止。

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665197434085.png)
1.2 同时打开与关闭

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665197539250.png)

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665197553431.png)
1.3 初始序列号
每一个连接都拥有不同的初始序列号。目的在于为一个连接的报文段安排的序列号防止出现与其他连接的序列号重叠的情况（**相同应该也没有关系，不是同一个链接？？**）。尤其对于**同一连接的两个不同实例**而言，新的序列号也不能出现重叠的情况。
同一连接的两个不同实例：以相同的四元组打开一个之前关闭的TCP连接。之前链接在网络中的滞留的包可能会被解释为当前连接的包，不同的初始序列号可避免该情况。

1.4 若连接建立超时则采用指数回退策略。

 2. TCP选项
![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665198815582.png)

2.1 最大段大小
最大段大小是指TCP协议所允许的从对方接收到的最大报文，因此这也是通信对方在发送数据时能够使用的最大报文段。最大段大小只记录TCP数据的字节数而不包括其他相关的TCP与IP头部。当建立一条TCP连接时,通信的每一方都要在SYN报文段的MSS选项中说明自已允许的最大段大小。

2.2 选择确认选项
通过接收SYN (或者SYN+ACK)报文段中的“允许选择确认”选项,，TCP通信方会了解到自身具有了发布SACK信息的能力。当接收到乱序的数据时，它就能提供一个SACK选项来描述这些乱序的数据，从而帮助对方有效地进行重传。SACK信息保存于SACK选项中,包含了接收方已经成功接收的数据块的序列号范围。

2.3 窗口缩放选项
窗口缩放选项能够有效地将TCP窗口字段的范围从16位增加至30位。使用该选项作为这16位数值的比例因子。该比例因子能够使窗口字段值有效地左移。这样事实上将窗口数值扩大至原先的2^s倍,其中s为比例因子，范围为0~14。该选项只能出现于一个SYN报文段中。

2.4 时间戳选项
当使用时间戳选项时，发送方将一个32位的数值填充到时间戳数值字段(TSV)作为时间戳选项的第一个部分；而接收方则将收到的时间戳数值原封不动地填充至第二部分的时间戳回显重试字段TSER)。由于包含了时间戳选项，TCP头部的长度将会增长10字节(8字节用于保存2个时间戳数值，而另2个数值则用于指明选项的数
值与长度)。

3.TCP的MTU发现算法







TIME_WAIT状态：
（1）防止最后发出的ACK丢失。
（2）避免之后建立的新的同一连接（相同四元组）将旧链接滞留在网络中的数据包解释为新连接的包。等待2MSL时间可保证旧链接所有数据包都已湮灭。

## 第14章 TCP超时与重传
1.TCP拥有两套独立机制来完成重传，一是基于时间，二是基于确认信息的构成。
（1）TCP在发送数据时会设置一个计时器,若至计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为**重传超时(RTO)**。
（2）另一种方式的重传称为**快速重传**，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息(SACK)表明出现失序报文段时，快速重传会推断出现丢包。

2.TCP拥有两个阈值来决定如何重传同一个报文段。
（1）R1表示TCP在向IP层传递“消极建议” (如重新评估当前的IP路径)前，愿意尝试重传的次数。
（2）R2(大于R1)指示TCP应放弃当前连接的时机。 
（3）R1和R2应分别至少设为三次重传和100秒。对连接的建立过程(发送SYN报文段)，阈值设置与数据段传输有所区别，针对SYN报文段的R2应最少设为3分钟。

3.重传超时时间(RTO)的设置
3.1 平滑的RTT估计值(SRTT)  
（1）SRTT = *α*(SRTT)  + (1 - *α*)RTT    常量α为平滑因子 *α*=0.8~0.9
（2）RTO = min(ubound, max(lbound,(SRTT)*β*))    常量β为时延离散因子 *β*=1.3~2.0
（3）仅平滑RTT，若TCP运行于RTT变化较大的网络中无法获得期望的效果。

3.2 上述方法的改进，同时平滑RTT和偏差
（1）srtt = (1 - *g*)(srtt) + (*g*)*M*   *M*为RTT测量值   增量*g*为新RTT样本*M*占srtt估计值的权重,取为1/8
（2）rttvar = (1 - h)(rttvar) + (h)(|M - srtt|)  增量*h*为新平均偏差样本占偏差估计值rttvar的权重,取为1/4
（3）RTO = srtt + 4(rttvar)
（4）初始化：srtt = *M* ，rttval = *M*/2

3.3 重传二义性
假设一个包的传输出现超时，该数据包会被重传，接着收到一个确认信息。那么该信息是对第一次还是第二次传输的确认就存在二义性。解决办法是在TCP头加入重传序列号，用序列号来唯一标识这次重传。

3.4 karn算法
当接收到重复传输数据的确认信息时，不进行该数据包的RTT测量，可以避免重传二义性问题。另外，对该数据之后的包采取退避策略。仅当接收到未经重传的数据时，该SRTT才用于计算RTO。
退避策略：如果超时重发的数据，再次超时的时候，TCP 的策略是超时时间间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。

3.5 带时间戳选项的RTT测量算法（RTTM）
（1）发送端每个报文段的TSV字段记录发送时刻的TCP时钟值。
（2）接收端记录其上一次发送的ACK号（LastACK）。当接收到序号为LastACK的报文段时，将其TSV值存入TsRecent。
（3）接收端发送的每一个ACK的TSER字段由TsRecent填充。
（4）发送端接收到ACK后，将当前TCP时钟减去TSER值得到新的RTT样本估计值。

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665142004843.png)

失序的鲁棒性：

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665143135390.png)
当报文段失序,返回的时间戳为接收端收到最近的有序报文段的时刻(即最新的使窗口前进的报文段)。这会使得发送端RTT样本增大，由此导致相应的RTO增大。由此发送端也不会急于重传。在失序情况下这是很有利的，因为过分积极的重传可能导致伪重传。**但是对丢包并不友好！！**

3.6 Linux采用的办法
问题：
（1）Linux的时间粒度更细，RTT样本的测量更为精确，易产生相互抵消的效果，导致rttval值随时间减小。
（2）某个RTT样本显著低于现有的RTT估计值srtt时,原有方法会增大rttvar导致RTO增大与实际不符。
改进：
（1）srtt = (1 - *g*)(srtt) + (*g*)*M*   *M*为RTT测量值   增量*g*为新RTT样本*M*占srtt估计值的权重,取为1/8
（2）mdev = (1 - h)(rttvar) + (h)(|M - srtt|)  增量*h*为新平均偏差样本占偏差估计值rttvar的权重,取为1/4
（3）rttval = mdev_max = max(mdev, mdev_max)
（4）RTO = srtt + 4(rttvar)
（5）初始化：srtt = *M* ，mdev = *M*/2

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665143487589.png)
4.超时重传
在设定计时器前，需记录被计时的报文段序列号，若及时收到了该报文段的ACK，那么计时器被取消。之后发送端发送一个新的数据包时，需设定一个新的计时器，并记录新的序列号。若在连接设定的RTO内, TCP没有收到被计时报文段的ACK，将会触发超时重传。
退避策略：如果超时重发的数据，再次超时的时候，TCP 的策略是超时时间间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。一旦接收到相应的ACK，TSO将会重置。

5.快速重传
TCP发送端在观测到至少3个重复ACK后,即重传可能丢失的数据分组,而不必等到重传计时器超时。
恢复点：发送端在执行重传前已发送的最大序列号。TCP在接收到序列号等于或大于恢复点的ACK时,才会被认为从重传中恢复。

6.带选择确认的重传（SACK）
```
    TCP SACK Option:
    Kind: 5

    Length: Variable
    +--------+--------+
    | Kind=5 | Length |
    +--------+--------+--------+--------+
    | Left Edge of 1st Block  |
    +--------+--------+--------+--------+
    | Right Edge of 1st Block |
    +--------+--------+--------+--------+
    | |
    / . . . /
    | |
    +--------+--------+--------+--------+
    | Left Edge of nth Block  |
    +--------+--------+--------+--------+
    | Right Edge of nth Block |
    +--------+--------+--------+--------+
```
SACK选项指定n个块的长度为8n+2字节，因此40字节的选项最多可包含4个块。每个SACK块包含2个32位
的序列号，代表接收端存储的**失序数据**的起始至最后一个序列号(加1)。
失序数据：接收端收到后引起失序情况的数据，即是序列号高于空缺部分的数据。

6.1 SACK接收端
（1）接收端在TCP连接建立期间收到SACK许可选项即可生成SACK。
（2）第一个SACK块内包含的是最近接收到的失序数据报文段的序列号范围。其余的SACK块包含的内容也按照接收的先后依次排列。
（3）最新一个SACK包中包含的内容除了包含最近接收的失序数据序列号信息，还需重复之前的SACK包的内容。

6.2 SACK发送端
（1）选择性重传：SACK发送端记录接收到的累积ACK信息，还需记录接收到的SACK信息，并利用该信息来避免重传正确接收的数据。
（2）SACK信息提供接收端数据的序列号范围，因此发送端可据此推断需要重传的空缺数据。最简单的方洼是使发送端首先填补接收端的空缺，然后再继续发送新数据。

7.伪超时与重传
在很多情况下即使没有出现数据丢失也可能引发重传。这种不必要的重传称为伪重传，其主要造成原因是伪超时即过早判定超时。
7.1 伪超时检测算法：
（1）DSACK
接收端在第一个SACK块中告知接收端收到的重复报文段序列号。一个SACK选项最多只能有DSACK块。
和普通的SACK块一样，DSACK块左边指定重复包的第一个字节的系列号，右边指定重复包最后一个字节的下一个系列号。
（2）Eifel检测算法
利用时间戳选项，保存重传包的TSV值，当接收到相应分组的ACK后，检查该ACK的TSER部分。若TSER值小于之前存储的TSV值，则可判定该ACK对应的是原始传输分组，即该重传是伪重传。
（3）F-RTO算法
在超时重传后收到第一个ACK时，TCP会发送新(非重传)数据，之后再响应后一个到达的ACK。如果其中有一个为重复ACK，则认为此次重传没问题。如果这两个都不是重复ACK，则表示该重传是伪重传。
如果新数据的传输得到了相应的ACK,就使得接收端窗口前移。如果新数据的发送导致了重复ACK,那么接收端至少有一个或更多的空缺。
7.2 伪超时响应算法：Eifel响应算法

