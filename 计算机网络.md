# 计算机网络协议——TCP/IP详解卷1
## 第1章 概述
1.数据报是一个特定类型的分组，**有关来源和最终目的地的所有识别信息都位于分组中(而不是分组交换机中)**。虽然这通常需要较大的数据包，但不需要在交换机中维护连接状态，它可用于建立一个无连接的网络，并且没必要使用复杂的信令协议。

2.消息边界或记录标记
![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665036911096.png)

3.在尽力而为的交付中，网络**不会花费很大努力**来确保数据在没有差错或缺陷的情况下交付。如果尽力而为的交付成功，发送方能以超过接收方处理能力的速度生成信息。在尽力而为的IP网络中，降低发送方的发送速度可通过**流量控制机制**实现。

## 第12章 TCP:传输控制协议（初步）
1.滑动窗口协议
接收方：
已经发送和确认的分组；已发送未被确认的分组；仍未被发送的分组

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665212173503.png)
接收方：
已经被接收和确认的分组；下一步期望接收的分组；即使被接收也将会因内存限制而被丢弃的分组

2.TCP服务模型：面向连接，广播和组播这些概念在TCP中都不存在。TCP提供一种字节流抽象概念给应用程序使用。这种设计方案的结果是没有由TCP自动插入的记录标志或消息边界。

3.TCP头部

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665213404483.png)
（1）源/目的端口：这两个值与IP头部中的源和目的IP地址一起，唯一地标识了每个连接。
（2）序列号：该报文段的数据中的第一个字节。
（3）确认号：该确认号的发送方期待接收的下一个序列号，确认号之前的字节均被接收并确认。
（4）头部长度：给出了头部的长度，以32位字为单位。
（5）控制字段
```
CWR——拥塞窗口减小，发送方降低它的发送速率
ECE——ECN回显,发送方接收到了一个更早的拥塞通告
URG——紧急,紧急指针字段有效
ACK——确认,确认号字段有效——连接建立以后一般都是启用状态
PSH——推送,接收方应尽快给应用程序传送这个数据
RST——重置连接
SYN——用于初始化一个连接的同步序列号
FIN——该报文段的发送方已经结束向对方发送数据
```
（6）窗口大小：用于窗口通告和拥塞控制，最大65535字节。接收方将本端剩余的窗口大小通知给发送端，发送端据此更新自己的窗口大小。
（7）TCP校验和：这个字段是强制的，由发送方进行计算和保存，然后由接收方验证
（8）紧急指针：紧急指针字段只有在URG位字段被设置时才有效，是一种让发送方给另一端提供特殊标志数据的方法
（9）选项：常见选项有最大段大小，SACK，时间戳，窗口缩放等。

## 第13章 TCP连接管理
1.TCP链接的建立与中止
一个TCP链接由一个**四元组唯一标识**，分别是两个IP地址和两个端日号。

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665197347549.png)
1.1 TCP半关闭
在TCP半关闭操作中,连接的一个方向被关闭，而另一个方向仍在传输数据直到它被关闭为
止。

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665197434085.png)
1.2 同时打开与关闭

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665197539250.png)

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665197553431.png)
1.3 初始序列号
每一个连接都拥有不同的初始序列号。目的在于为一个连接的报文段安排的序列号防止出现与其他连接的序列号重叠的情况（**相同应该也没有关系，不是同一个链接？？**）。尤其对于**同一连接的两个不同实例**而言，新的序列号也不能出现重叠的情况。
同一连接的两个不同实例：以相同的四元组打开一个之前关闭的TCP连接。之前链接在网络中的滞留的包可能会被解释为当前连接的包，不同的初始序列号可避免该情况。

1.4 若连接建立超时则采用指数回退策略。

 2. TCP选项
![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665198815582.png)

2.1 最大段大小
最大段大小是指TCP协议所允许的从对方接收到的最大报文，因此这也是通信对方在发送数据时能够使用的最大报文段。最大段大小只记录TCP数据的字节数而不包括其他相关的TCP与IP头部。当建立一条TCP连接时,通信的每一方都要在SYN报文段的MSS选项中说明自已允许的最大段大小。

2.2 选择确认选项
通过接收SYN (或者SYN+ACK)报文段中的“允许选择确认”选项,，TCP通信方会了解到自身具有了发布SACK信息的能力。当接收到乱序的数据时，它就能提供一个SACK选项来描述这些乱序的数据，从而帮助对方有效地进行重传。SACK信息保存于SACK选项中,包含了接收方已经成功接收的数据块的序列号范围。

2.3 窗口缩放选项
窗口缩放选项能够有效地将TCP窗口字段的范围从16位增加至30位。使用该选项作为这16位数值的比例因子。该比例因子能够使窗口字段值有效地左移。这样事实上将窗口数值扩大至原先的2^s倍,其中s为比例因子，范围为0~14。该选项只能出现于一个SYN报文段中。

2.4 时间戳选项
当使用时间戳选项时，发送方将一个32位的数值填充到时间戳数值字段(TSV)作为时间戳选项的第一个部分；而接收方则将收到的时间戳数值原封不动地填充至第二部分的时间戳回显重试字段TSER)。由于包含了时间戳选项，TCP头部的长度将会增长10字节(8字节用于保存2个时间戳数值，而另2个数值则用于指明选项的数
值与长度)。

3.TCP的MTU发现算法
试探法：将IP字段的DF位设置为不允许分片，测试不同的传输单元值，根据icmp的错误反馈信息来调整该值，直到找到该MTU值。

4.TCP状态转移图

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665203824261.png)

4.1 TIME_WAIT状态
（1）防止最后发出的ACK丢失。
（2）避免之后建立的新的同一连接（相同四元组）将旧链接滞留在网络中的数据包解释为新连接的包。等待2MSL时间可保证旧链接所有数据包都已湮灭。
注1：考虑一种极端情况，发送端发送一个报文段刚好在MSL时间到达接收端，接收端发送的ACK又刚好在MSL时间到达发送端。因此等待2MSL时间没有接收到报文说明该连接所有报文均已湮灭。
注2：在TIME_WAIT状态接收到当前连接的报文段被称为时间等待错误。一个重置报文段能破坏TIME_WAIT状态并强制连接提前关闭。目前有很多方法来阻止这一问题,其中包括在处于TIME_WAIT状态时忽略重置报文段。

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665210590793.png)
4.2 静默时间
如果一台与处于TIME_WAIT状态下的连接相关联的服务器崩溃，然后在MSL内重新启动，并且使用与服务器崩溃之前处于TIME_WAIT状态的连接相同的IP地址与端口号，那么该连接在服务器崩溃之前产生的延迟报文段会被认为属于服务器重启后创建的新连接。这种处理方式将不会考虑在服务器重启之后新连接是如何选择初始序列号的。
为了防止上述情况的发生，在崩溃或者重启后TCP协议应当在创建新的连接之前等待相当于一个MSL的时间。该段时间被称作静默时间。等待MSL时间可保证对端发送的所有数据包均已湮灭。

5.重置报文段场景
（1）不存在端口的连接请求：当一个连接请求到达本地却没有相关进程在目的端口侦听时就会产生一个重置报文段，UDP则是产生一个icmp端口不可达错误消息。
（2）终止释放：在任何时刻，都可以通过发送一个重置报文段替代FIN来终止一条连接。采用该方式：任何排队的数据都将被抛弃，一个重置报文段会被立即发送出去；重置报文段的接收方会说明通信另一端采用了终止的方式而不是一次正常关闭。
（3）半开链接：服务器主机被切断连接后重启，留给客户端一个半开的连接。当再次从这条连接上接收到其他数据时，服务器对其一无所知。在服务器回复一个重置报文段作为响应之后，两端之间的连接会被关闭。
（4）时间等待错误：在TIME_WAIT状态接收到当前连接的报文段。一个重置报文段能破坏TIME_WAIT状态并强制连接提前关闭。目前有很多方法来阻止这一问题,其中包括在处于TIME_WAIT状态时忽略重置报文段。

6.服务器的两个队列
（1）处于SYN_RCVD状态的连接队列，该队列默认最大值1000，超过该值进入的链接将被拒绝。
（2）处于ESRABLISHED状态但未被应用程序接收的队列。该队列默认最大值128。

## 第14章 TCP超时与重传
1.TCP拥有两套独立机制来完成重传，一是基于时间，二是基于确认信息的构成。
（1）TCP在发送数据时会设置一个计时器,若至计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为**重传超时(RTO)**。
（2）另一种方式的重传称为**快速重传**，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息(SACK)表明出现失序报文段时，快速重传会推断出现丢包。

2.TCP拥有两个阈值来决定如何重传同一个报文段。
（1）R1表示TCP在向IP层传递“消极建议” (如重新评估当前的IP路径)前，愿意尝试重传的次数。
（2）R2(大于R1)指示TCP应放弃当前连接的时机。 
（3）R1和R2应分别至少设为三次重传和100秒。对连接的建立过程(发送SYN报文段)，阈值设置与数据段传输有所区别，针对SYN报文段的R2应最少设为3分钟。

3.重传超时时间(RTO)的设置
直观上看,发送方在重发一个分组之前应等待的时间量大概是下面时间的总和:发送分组所用的时间,接收方处理它和发送一个ACK所用的时间, ACK返回到发送方所用的时间,以及发送方处理ACK所用的时间。
不幸的是,实际上这些时间没有一个是可以确切知道的。更糟的是,它们中的某些或全部会随着来自终端主机或路由器的额外负载的增加或减少而随时改变。更好的策略是让协议实现尝试去估计往返时间。

3.1 平滑的RTT估计值(SRTT)  
（1）SRTT = *α*(SRTT)  + (1 - *α*)RTT    常量α为平滑因子 *α*=0.8~0.9
（2）RTO = min(ubound, max(lbound,(SRTT)*β*))    常量β为时延离散因子 *β*=1.3~2.0
（3）仅平滑RTT，若TCP运行于RTT变化较大的网络中无法获得期望的效果。

3.2 上述方法的改进，同时平滑RTT和偏差
（1）srtt = (1 - *g*)(srtt) + (*g*)*M*   *M*为RTT测量值   增量*g*为新RTT样本*M*占srtt估计值的权重,取为1/8
（2）rttvar = (1 - h)(rttvar) + (h)(|M - srtt|)  增量*h*为新平均偏差样本占偏差估计值rttvar的权重,取为1/4
（3）RTO = srtt + 4(rttvar)
（4）初始化：srtt = *M* ，rttval = *M*/2

3.3 重传二义性
假设一个包的传输出现超时，该数据包会被重传，接着收到一个确认信息。那么该信息是对第一次还是第二次传输的确认就存在二义性。解决办法是在TCP头加入重传序列号，用序列号来唯一标识这次重传。

3.4 karn算法
当接收到重复传输数据的确认信息时，不进行该数据包的RTT测量，可以避免重传二义性问题。另外，对该数据之后的包采取退避策略。仅当接收到未经重传的数据时，该SRTT才用于计算RTO。
退避策略：如果超时重发的数据，再次超时的时候，TCP 的策略是超时时间间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。

3.5 带时间戳选项的RTT测量算法（RTTM）
（1）发送端每个报文段的TSV字段记录发送时刻的TCP时钟值。
（2）接收端记录其上一次发送的ACK号（LastACK）。当接收到序号为LastACK的报文段时，将其TSV值存入TsRecent。
（3）接收端发送的每一个ACK的TSER字段由TsRecent填充。
（4）发送端接收到ACK后，将当前TCP时钟减去TSER值得到新的RTT样本估计值。

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665142004843.png)

失序的鲁棒性：

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665143135390.png)
当报文段失序,返回的时间戳为接收端收到最近的有序报文段的时刻(即最新的使窗口前进的报文段)。这会使得发送端RTT样本增大，由此导致相应的RTO增大。由此发送端也不会急于重传。在失序情况下这是很有利的，因为过分积极的重传可能导致伪重传。**但是对丢包并不友好！！**

3.6 Linux采用的办法
问题：
（1）Linux的时间粒度更细，RTT样本的测量更为精确，易产生相互抵消的效果，导致rttval值随时间减小。
（2）某个RTT样本显著低于现有的RTT估计值srtt时,原有方法会增大rttvar导致RTO增大与实际不符。
改进：
（1）srtt = (1 - *g*)(srtt) + (*g*)*M*   *M*为RTT测量值   增量*g*为新RTT样本*M*占srtt估计值的权重,取为1/8
（2）mdev = (1 - h)(rttvar) + (h)(|M - srtt|)  增量*h*为新平均偏差样本占偏差估计值rttvar的权重,取为1/4
（3）rttval = mdev_max = max(mdev, mdev_max)
（4）RTO = srtt + 4(rttvar)
（5）初始化：srtt = *M* ，mdev = *M*/2

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665143487589.png)
4.超时重传
在设定计时器前，需记录被计时的报文段序列号，若及时收到了该报文段的ACK，那么计时器被取消。之后发送端发送一个新的数据包时，需设定一个新的计时器，并记录新的序列号。若在连接设定的RTO内, TCP没有收到被计时报文段的ACK，将会触发超时重传。
退避策略：如果超时重发的数据，再次超时的时候，TCP 的策略是超时时间间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。一旦接收到相应的ACK，TSO将会重置。

5.快速重传
TCP发送端在观测到至少3个重复ACK后,即重传可能丢失的数据分组,而不必等到重传计时器超时。
恢复点：发送端在执行重传前已发送的最大序列号。TCP在接收到序列号等于或大于恢复点的ACK时,才会被认为从重传中恢复。

6.带选择确认的重传（SACK）
```
    TCP SACK Option:
    Kind: 5

    Length: Variable
    +--------+--------+
    | Kind=5 | Length |
    +--------+--------+--------+--------+
    | Left Edge of 1st Block  |
    +--------+--------+--------+--------+
    | Right Edge of 1st Block |
    +--------+--------+--------+--------+
    | |
    / . . . /
    | |
    +--------+--------+--------+--------+
    | Left Edge of nth Block  |
    +--------+--------+--------+--------+
    | Right Edge of nth Block |
    +--------+--------+--------+--------+
```
SACK选项指定n个块的长度为8n+2字节，因此40字节的选项最多可包含4个块。每个SACK块包含2个32位
的序列号，代表接收端存储的**失序数据**的起始至最后一个序列号(加1)。
失序数据：接收端收到后引起失序情况的数据，即是序列号高于空缺部分的数据。

6.1 SACK接收端
（1）接收端在TCP连接建立期间收到SACK许可选项即可生成SACK。
（2）第一个SACK块内包含的是最近接收到的失序数据报文段的序列号范围。其余的SACK块包含的内容也按照接收的先后依次排列。
（3）最新一个SACK包中包含的内容除了包含最近接收的失序数据序列号信息，还需重复之前的SACK包的内容。

6.2 SACK发送端
（1）选择性重传：SACK发送端记录接收到的累积ACK信息，还需记录接收到的SACK信息，并利用该信息来避免重传正确接收的数据。
（2）SACK信息提供接收端数据的序列号范围，因此发送端可据此推断需要重传的空缺数据。最简单的方洼是使发送端首先填补接收端的空缺，然后再继续发送新数据。

7.伪超时与重传
在很多情况下即使没有出现数据丢失也可能引发重传。这种不必要的重传称为伪重传，其主要造成原因是伪超时即过早判定超时。
7.1 伪超时检测算法：
（1）DSACK
接收端在第一个SACK块中告知接收端收到的重复报文段序列号。一个SACK选项最多只能有DSACK块。
和普通的SACK块一样，DSACK块左边指定重复包的第一个字节的系列号，右边指定重复包最后一个字节的下一个系列号。该方法检测到的伪超时称为**迟伪超时**。
（2）Eifel检测算法
利用时间戳选项，保存重传包的TSV值，当接收到相应分组的ACK后，检查该ACK的TSER部分。若TSER值小于之前存储的TSV值，则可判定该ACK对应的是原始传输分组，即该重传是伪重传。
（3）F-RTO算法
在超时重传后收到第一个ACK时，TCP会发送新(非重传)数据，之后再响应后一个到达的ACK。如果其中有一个为重复ACK，则认为此次重传没问题。如果这两个都不是重复ACK，则表示该重传是伪重传。
如果新数据的传输得到了相应的ACK,就使得接收端窗口前移。如果新数据的发送导致了重复ACK,那么接收端至少有一个或更多的空缺。

**区别**：伪超时通过检查ACK或原始传输来实现。迟伪超时基于由(伪)超时而引发的重传所返回的ACK来判定。前者检测到伪超时所需时间短，后者则较长。

7.2 伪超时响应算法：Eifel响应算法
在任何一次计时器超时后，设定以下两个变量，但只有在发生伪超时才会使用：
（1）srtt_prev = srtt + 2(G)  G为TCP时钟颗粒，目的是增大srtt防止伪超时
（2）rttvar_prev = rttvar
之后运行伪超时检测算法，分为以下两种情况，但响应算法只针对第一种情况：
（1）伪超时：将下一个要发送的报文修改为最新的未发送过的报文段，避免了”回退N“行为。
（2）迟伪超时：不做处理。
原因是：迟伪超时所需时间长，”回退N“行为已经发生，响应算法无法改变这一事实。
最后一步更新RTO：
（1）srtt = max(srtt_prev, *m*)    *m*是基于超时后首个发送数据收到的ACK而计算得到的个RTT样本值
（2）rttval = max(rttval_prev, *m*/2)
（3）RTO = srtt + max(G,4(rttval))
考虑以下两种情况：
（1）若路径上的实际RTT突然增大，当前的srtt和rttvar就显得过小，应重新设置。
（2）RTT的增大可能只是暂时的，这时重设srtt和rttvar的值就不明智，因为它们原先的值可能更为精确。
在新RTT样本值较大的情况下，上述等式尽力获得上述两种情况的平衡。

8.包失序与包重复都可能触发伪快速重传

![包失序导致伪快速重传](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665217744142.png)
解决办法：动态调整快速重传的ACK阈值。

![包重复导致伪快速重传](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665217857408.png)
解决办法：DSACK，包含数据序列的重复信息而无失序信息，说明一定是重复信息。

9.目的度量
当创立一个新的连接时，首先查看数据结构中是否存在与该目的端的先前通信信息。如果存在，则选择较近的信息，据此为srtt、rttvar以及其他变量设初值。在TCP连接关闭前，可更新统计数据，通过替换现存数据或其他方式的更新来实现。

