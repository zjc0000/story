# 计算机网络协议——TCP/IP详解卷1
## 第1章 概述
1.数据报是一个特定类型的分组，**有关来源和最终目的地的所有识别信息都位于分组中(而不是分组交换机中)**。虽然这通常需要较大的数据包，但不需要在交换机中维护连接状态，它可用于建立一个无连接的网络，并且没必要使用复杂的信令协议。

2.消息边界或记录标记
![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665036911096.png)

3.在尽力而为的交付中，网络**不会花费很大努力**来确保数据在没有差错或缺陷的情况下交付。如果尽力而为的交付成功，发送方能以超过接收方处理能力的速度生成信息。在尽力而为的IP网络中，降低发送方的发送速度可通过**流量控制机制**实现。

## 第12章 TCP:传输控制协议（初步）

## 第13章 TCP连接管理
TIME_WAIT状态：
（1）防止最后发出的ACK丢失。
（2）避免之后建立的新的同一连接（相同四元组）将旧链接滞留在网络中的数据包解释为新连接的包。等待2MSL时间可保证旧链接所有数据包都已湮灭。

## 第14章 TCP超时与重传
1.TCP拥有两套独立机制来完成重传，一是基于时间，二是基于确认信息的构成。
（1）TCP在发送数据时会设置一个计时器,若至计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为**重传超时(RTO)**。
（2）另一种方式的重传称为**快速重传**，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息(SACK)表明出现失序报文段时，快速重传会推断出现丢包。

2.TCP拥有两个阈值来决定如何重传同一个报文段。
（1）R1表示TCP在向IP层传递“消极建议” (如重新评估当前的IP路径)前，愿意尝试重传的次数。
（2）R2(大于R1)指示TCP应放弃当前连接的时机。 
（3）R1和R2应分别至少设为三次重传和100秒。对连接的建立过程(发送SYN报文段)，阈值设置与数据段传输有所区别，针对SYN报文段的R2应最少设为3分钟。

3.重传超时时间(RTO)的设置
3.1 平滑的RTT估计值(SRTT)  
（1）SRTT = *α*(SRTT)  + (1 - *α*)RTT    常量α为平滑因子 *α*=0.8~0.9
（2）RTO = min(ubound, max(lbound,(SRTT)*β*))    常量β为时延离散因子 *β*=1.3~2.0
（3）仅平滑RTT，若TCP运行于RTT变化较大的网络中无法获得期望的效果。

3.2 上述方法的改进，同时平滑RTT和偏差
（1）srtt = (1 - *g*)(srtt) + (*g*)*M*   *M*为RTT测量值   增量*g*为新RTT样本*M*占srtt估计值的权重,取为1/8
（2）rttvar = (1 - h)(rttvar) + (h)(|M - srtt|)  增量*h*为新平均偏差样本占偏差估计值rttvar的权重,取为1/4
（3）RTO = srtt + 4(rttvar)
（4）初始化：srtt = *M* ，rttval = *M*/2

3.3 重传二义性
假设一个包的传输出现超时，该数据包会被重传，接着收到一个确认信息。那么该信息是对第一次还是第二次传输的确认就存在二义性。解决办法是在TCP头加入重传序列号，用序列号来唯一标识这次重传。

3.4 karn算法
当接收到重复传输数据的确认信息时，不进行该数据包的RTT测量，可以避免重传二义性问题。另外，对该数据之后的包采取退避策略。仅当接收到未经重传的数据时，该SRTT才用于计算RTO。
退避策略：如果超时重发的数据，再次超时的时候，TCP 的策略是超时时间间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。

3.5 带时间戳选项的RTT测量算法（RTTM）
（1）发送端每个报文段的TSV字段记录发送时刻的TCP时钟值。
（2）接收端记录其上一次发送的ACK号（LastACK）。当接收到序号为LastACK的报文段时，将其TSV值存入TsRecent。
（3）接收端发送的每一个ACK的TSER字段由TsRecent填充。
（4）发送端接收到ACK后，将当前TCP时钟减去TSER值得到新的RTT样本估计值。

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665142004843.png)

失序的鲁棒性：

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665143135390.png)
当报文段失序,返回的时间戳为接收端收到最近的有序报文段的时刻(即最新的使窗口前进的报文段)。这会使得发送端RTT样本增大，由此导致相应的RTO增大。由此发送端也不会急于重传。在失序情况下这是很有利的，因为过分积极的重传可能导致伪重传。**但是对丢包并不友好！！**

3.6 Linux采用的办法
问题：
（1）Linux的时间粒度更细，RTT样本的测量更为精确，易产生相互抵消的效果，导致rttval值随时间减小。
（2）某个RTT样本显著低于现有的RTT估计值srtt时,原有方法会增大rttvar导致RTO增大与实际不符。
改进：
（1）srtt = (1 - *g*)(srtt) + (*g*)*M*   *M*为RTT测量值   增量*g*为新RTT样本*M*占srtt估计值的权重,取为1/8
（2）mdev = (1 - h)(rttvar) + (h)(|M - srtt|)  增量*h*为新平均偏差样本占偏差估计值rttvar的权重,取为1/4
（3）rttval = mdev_max = max(mdev, mdev_max)
（4）RTO = srtt + 4(rttvar)
（5）初始化：srtt = *M* ，mdev = *M*/2

![](https://raw.githubusercontent.com/zjc0000/story_images/main/小书匠/1665143487589.png)
4.超时重传
在设定计时器前，需记录被计时的报文段序列号，若及时收到了该报文段的ACK，那么计时器被取消。之后发送端发送一个新的数据包时，需设定一个新的计时器，并记录新的序列号。若在连接设定的RTO内, TCP没有收到被计时报文段的ACK，将会触发超时重传。
退避策略：如果超时重发的数据，再次超时的时候，TCP 的策略是超时时间间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。一旦接收到相应的ACK，TSO将会重置。

5.快速重传
TCP发送端在观测到至少3个重复ACK后,即重传可能丢失的数据分组,而不必等到重传计时器超时。
恢复点：发送端在执行重传前已发送的最大序列号。TCP在接收到序列号等于或大于恢复点的ACK时,才会被认为从重传中恢复。

6.带选择确认的重传（SACK）
